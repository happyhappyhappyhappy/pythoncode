* 1回目
* 2次元配列を使う手前,pprintモジュールをインポートする
    * 表示時には`pprint.pprint(list,list)`で行う→すぐ分かる
* まずは1テストだけみてだけ見て確認する
* 面積にとらわれていると何故か範囲外に飛んでしまうので、一つ一つの条件に合ったマスを消していくことにする。
* `surface = [[0] * (Width+1) for _ in range(0, Height+1, +1)]`
    * で、図版を作ると横と高さのグラフは正しく作れるが
    * `surface[y][x] = 1`と逆順に書き込みしないと、プロットが間違える
        * イメージとしては`surface[x][y]=1`にしたいのだが
* どうも図形＝配列をイメージして作ってしまうともたない
    * `<`を`<=`とすると上手くいくのでは
* sample3でつまづく。休憩。
    * 素直に面積で出していく、保留
* C++版見てみるとわざわざ画面を+1にしないでwidth*heightで宣言の上、素直に`<`で探している
* 1回目その2
    * C++環境の解答に合わせてやってみる。ただし配列の作り方はnumpyを利用する
    * 結果、numpyで配列作って見てもNG
    * やはり範囲を縮めて面積を求める形になるのか
    * 解散
* 1回目その3
    * C++の解答をもう一回見ると、四角形ずつ塗りつぶす処理が入っている
        * 全面なめて条件判定している訳では無い
        * それを踏まえて作成
    * [完了](https://atcoder.jp/contests/abc047/submissions/14489276)
        * 今回はnumpyを使ったためメモリも実行時間も長い
        * [単なるリストを使った方法](https://atcoder.jp/contests/abc047/submissions/3961977)より長い。ただわかりやすいからこれで良し。
* 2回目
    * 図面のシミュレーションではなく長さで表現
    * はまりました
        * サンプルは出来たが、サーバーに渡すといくつか失敗する
            * `x_label_min = x_list[j]`の様に即座に入れてはダメ
                * 大小を確認してから入れる入れる
    * [完了](https://atcoder.jp/contests/abc047/submissions/14715241)
        * numpyと同じくらい
    * 次回は[これ](https://atcoder.jp/contests/abc047/submissions/14683985)を参考にして、逐一三つのリストを使わないようにする
* 3回目
    * 長さで判断その2
    * 今回はx,y,操作のリストを二次元リストとして入れた
    * [完了](https://atcoder.jp/contests/abc047/submissions/14958377)
        * 前回との違いはmin,maxを使っていること
